<link rel="import" href="../bower_components/polymer/polymer.html">

<script src="../bower_components/threejs/build/three.min.js"></script>
<script src="../bower_components/threex.domevents/threex.domevents.js"></script>
<script src="../js/axis-controls.js"></script>
<script src="../js/zoom-control.js"></script>

<!-- WebVR -->
<script>
    WebVRConfig = {
        // To disable keyboard and mouse controls, if you want to use your own implementation.
        MOUSE_KEYBOARD_CONTROLS_DISABLED: true,

        // Scales the recommended buffer size reported by WebVR, which can improve performance.
        BUFFER_SCALE: 1.0
    };
</script>
<script src="../bower_components/webvr-polyfill/build/webvr-polyfill.js"></script>
<script src="../bower_components/threejs/examples/js/controls/VRControls.js"></script>
<script src="../bower_components/threejs/examples/js/effects/VREffect.js"></script>

<dom-module id="vr-scene">
    <template>
        <style>
            button {
                position: fixed;
                top: 0;
                left: 0;
                padding: 10px;
                z-index: 1;
                background: white;
            }
        </style>

        <button on-click="_enterVR">Enter VR (WebVR/Mobile only)</button>
        <content id="content" select="*"></content>
    </template>
</dom-module>

<script>
    Polymer({
        is: "vr-scene",

        ready: function () {
            var self = this;
            self.renderer = self._createRenderer();
            self.camera = self._createCamera(self.renderer.domElement);
            self.scene = new THREE.Scene();

            // domEvents to listen for dom events inside our 3d scene
            // attention global
            domEvents = new THREEx.DomEvents(self.camera, self.renderer.domElement);
            THREE.Object3D.prototype.on = function(eventName, callback, useCapture) {
                domEvents.bind(this, eventName, callback, useCapture);
            };
            THREE.Object3D.prototype.off = function(eventName, callback, useCapture) {
                domEvents.unbind(this, eventName, callback, useCapture);
            };

            self.group = self._createGroup(self.renderer.domElement);
            self.scene.add(self.camera);
            self.scene.add(self.group);

            Polymer.dom(self.root).appendChild(self.renderer.domElement);

            // observe nodes that will added to this element
            Polymer.dom(self.$.content).observeNodes(function (nodes) {
                nodes.addedNodes.forEach(function (node) {
                    self.group.add(node.obj);

                    // register click listener
                    domEvents.addEventListener(node.obj, 'click', function () {
                        if (node.onClick) {
                            node.onClick();
                        }
                    }, false);

                    // register mousedown for move-element.js
                    domEvents.addEventListener(node.obj, 'mousedown', function () {
                        if(node.down)
                            node.down()
                    }, false);

                });

                nodes.removedNodes.forEach(function (node) {
                    self.group.remove(node.obj);
                });
            });

            // WebVR
            self.controls = new THREE.VRControls(self.camera);
            self.effect = new THREE.VREffect(self.renderer);
            self.effect.setSize(window.innerWidth, window.innerHeight);
            navigator.getVRDisplays().then(function (displays) {
                if (displays.length > 0) {
                    self.vrDisplay = displays[0];
                }
            });

            // Resize the WebGL canvas when we resize and also when we change modes.
            this.listen(window, 'resize', '_onResize');
            this.listen(window, 'vrdisplaypresentchange', '_onResize');

            // start rendering
            self._render();
        },

        _createRenderer: function () {
            var renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0xf0f0f0);
            return renderer;
        },

        _createCamera: function (dom) {
            var camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 1000);
            camera.add(new THREE.PointLight(0xffffff));
            new THREE.ZoomControl(camera, dom);
            return camera;
        },

        _createGroup: function (dom) {
            var group = new THREE.Group();
            group.position.setZ(-200);
            new THREE.AxisControls(group, dom);
            return group;
        },

        _render: function () {
            requestAnimationFrame(this._render.bind(this));
            this.controls.update();
            this.effect.render(this.scene, this.camera);
        },

        _enterVR: function () {
            this.vrDisplay.requestPresent([{source: this.renderer.domElement}]);
            var crosshair = new THREE.Mesh(
                    new THREE.RingGeometry( 0.02, 0.04, 32 ),
                    new THREE.MeshBasicMaterial( {
                        color: 0x000000,
                        opacity: 0.5,
                        transparent: true
                    } )
            );
            crosshair.position.z = - 2;
            this.camera.add(crosshair);
        },

        _onResize: function () {
            console.log('Resizing to %s x %s.', window.innerWidth, window.innerHeight);
            this.effect.setSize(window.innerWidth, window.innerHeight);
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
        }

    });
</script>
