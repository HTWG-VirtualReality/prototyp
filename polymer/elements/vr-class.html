<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../behaviors/vr-move.html">
<link rel="import" href="../behaviors/vr-resize.html">
<link rel="import" href="../behaviors/vr-delete.html">
<link rel="import" href="../behaviors/vr-connect-extended.html">
<link rel="import" href="../behaviors/vr-look.html">
<link rel="import" href="../behaviors/vr-highlight.html">
<link rel="import" href="./vr-box.html">

<script src="../js/vr-size-datastruct.js"></script>

<dom-module id="vr-class">
    <template>
        <template is="dom-repeat" items="{{boxItems}}">
            <vr-box x-pos="{{item.x}}" y-pos="{{item.y}}" width="{{item.width}}"
                    height="{{item.height}}" depth="{{item.depth}}"
                    text="{{item.text}}" text-center="{{item.textCenter}}"></vr-box>
        </template>
    </template>
</dom-module>

<script>
    window.VrElement = window.VrElement || {};
    VrElement.Class = Polymer({
        is: "vr-class",

        properties: {
            maxWidth: {
                type: Number,
                value: 200,
                readOnly: true
            },
            text1: {
                type: String,
                value: ''
            },
            text2: {
                type: String,
                value: ''
            },
            text3: {
                type: String,
                value: ''
            },
            classType: {
                type: String,
                value: 'class',
                observer: '_enumClassType'
            }
        },

        behaviors: [
            VrBehavior.Move,
            VrBehavior.Resize,
            VrBehavior.Delete,
            VrBehavior.ConnectExtended,
            VrBehavior.Look
        ],

        observers: [
            '_updateClass(xPos, yPos, width, height, depth, text1, text2, text3, classType)'
        ],

        _enumClassType: function (newValue) {
            var validTypes = ['class', 'abstract', 'interface'];
            if (validTypes.indexOf(newValue) === -1) {
                // set default value
                this.classType = 'class';
            }
        },

        _updateClass: function (xPos, yPos, width, height, depth, text1, text2, text3, classType) {
            if (this.getThreeJS()) {
                // compute width for fitting the text
                var newWidth = this._computeWidth();
                if (newWidth > 0) {
                    this.width = newWidth < this.maxWidth ? newWidth : this.maxWidth;
                }

                if (this.boxItems) {
                    var properties = this._getBoxItemProperties(this.width, height, depth, text1, text2, text3, classType);
                    this.splice('boxItems', 0, 3, properties[0], properties[1], properties[2]);
                }
                this.fire('vr-resize', {});
            }
        },

        _computeWidth: function () {
            // TODO: texture erstellung auslagern
            var dynamicTexture = new THREEx.DynamicTexture(this.width * 10, this.height * 10);
            dynamicTexture.texture.minFilter = THREE.NearestFilter;
            var maxWidth = 0;

            calcMax(this.text1);
            calcMax(this.text2);
            calcMax(this.text3);

            function calcMax(text) {
                var texts = text.split(THREEx.linebreak);
                texts.forEach(function (text) {
                    var newWidth = dynamicTexture.computeWidth(text, "64px Verdana");
                    if (newWidth > maxWidth) {
                        maxWidth = newWidth;
                    }
                });
            }

            return maxWidth / 10;
        },

        ready: function () {
            // setUp size information => gets generated
            this.sizeInformations = {
                "0": VrSizeDatastruct({height: 25}, {height: 25}, {height: 0.2, width:1}),
                "1": VrSizeDatastruct(null, null, {height: 0.4, width:1}),
                "2": VrSizeDatastruct(null, null, {height: 0.4, width:1})
            }
            this.getThreeJS().on('click', this.onClick.bind(this));
            this.boxItems = this._getBoxItemProperties(this.width, this.height, this.depth, this.text1, this.text2, this.text3, this.classType);
        },

        attached: function () {
            this._getChildren().forEach(function (box) {
                this.getThreeJS().add(box.getThreeJS());
            }.bind(this));
        },

        _getChildren: function () {
            // return all children except template element
            return Polymer.dom(this.root).children.filter(function (node) {
                return node.localName != 'template';
            });
        },

        _getBoxItemProperties: function (width, height, depth, text1, text2, text3, classType) {
            var texts = [text1, text2, text3];
            var y = 0;

            var size = (calculateSize.bind(this))([], width, height, 1, Object.keys(this.sizeInformations), 0);
            var y = 0;
            var properties = size.map(function(size, i){
                var position = {x: 0, y: y};
                y -= size.height;
                return createProperties(position, size, texts[i])
            });

            return properties;

            function calculateSize(arr, width, height, percentage, posibilities, i) {
                var tmpHeight = 0;
                var tmpPercentage = 0;
                var tmpposibilities = [];
                for(var key in this.sizeInformations) {
                    if(posibilities.indexOf(String(key)) == -1) { continue; }
                    var tmp = this.sizeInformations[key](width, proportion(1), height, proportion(percentage));
                    tmpHeight += tmp.diffHeight;
                    tmpPercentage += tmp.percentageHeight;
                    arr = append(arr, key, tmp.size);
                    if(tmp.percentageHeight != 0) { tmpposibilities.push(key); }
                }

                if(tmpHeight == 0) { return arr; }
                return (calculateSize.bind(this))(arr, width, height + tmpHeight, tmpPercentage, tmpposibilities, ++i);

                function append(arr, index, value) {
                    index = parseInt(index, 10);
                    if(arr[index] === undefined) {
                        arr.push(value)
                    } else {
                        arr[index] = value;
                    }
                    return arr;
                }
            }

            function proportion(percentage) {
                return 1 / percentage;
            }

            function createProperties(position, size, text) {
                return {
                    x: position.x,
                    y: position.y - (size.height/2), // (size.height/2) to set y in center
                    width: size.width,
                    height: size.height,
                    depth: size.depth || 10,
                    text: text,
                    textCenter: true
                }
            }
        },

        // simple on click => triggered in vr-scene.html
        onClick: function () {
            var self = this;

            if (!this.gui) {
                var Menu = function () {
                    this.name = self.text1;
                    this.variables = self.text2;
                    this.functions = self.text3;
                    this.width = self.width;
                    this.height = self.height;
                    this.yPos = self.yPos;
                };
                var text = new Menu();
                this.gui = new dat.GUI();
                var text1Controller = this.gui.add(text, 'name');
                var text2Controller = this.gui.add(text, 'variables');
                var text3Controller = this.gui.add(text, 'functions');
                var yPosController = this.gui.add(text, 'yPos', -200, 200);
                var widthController = this.gui.add(text, 'width', 30, 200);
                var heightController = this.gui.add(text, 'height', 30, 200);

                text1Controller.onFinishChange(function (text) {
                    self.text1 = text;
                });
                text2Controller.onFinishChange(function (text) {
                    self.text2 = text;
                });
                text3Controller.onFinishChange(function (text) {
                    self.text3 = text;
                });
                yPosController.onFinishChange(function (yPos) {
                    self.yPos = yPos;
                });
                widthController.onFinishChange(function (width) {
                    self.width = width;
                });
                heightController.onFinishChange(function (height) {
                    self.height = height;
                });
            } else {
                this.gui.destroy();
                this.gui = null;
            }
        }

    });
</script>
