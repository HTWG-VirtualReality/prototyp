<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../behaviors/vr-move.html">
<link rel="import" href="../behaviors/vr-resize.html">
<link rel="import" href="../behaviors/vr-delete.html">
<link rel="import" href="../behaviors/vr-connect-extended.html">
<link rel="import" href="../behaviors/vr-look.html">
<link rel="import" href="../behaviors/vr-class-control.html">
<link rel="import" href="./vr-box.html">

<dom-module id="vr-class">
    <template>
        <template is="dom-repeat" items="{{boxItems}}">
            <vr-box x-pos="{{item.x}}"
                    y-pos="{{item.y}}"
                    width="{{item.width}}"
                    height="{{item.height}}"
                    depth="{{item.depth}}"
                    text="{{item.text}}"
                    text-center="{{item.textCenter}}"
                    parent-highlight>
            </vr-box>
        </template>
    </template>
</dom-module>

<script>
    window.VrElement = window.VrElement || {};
    VrElement.Class = Polymer({
        is: "vr-class",

        properties: {
            maxWidth: {
                type: Number,
                value: 200,
                readOnly: true
            },
            text1: {
                type: String,
                value: ''
            },
            text2: {
                type: String,
                value: ''
            },
            text3: {
                type: String,
                value: ''
            },
            classType: {
                type: String,
                value: 'class',
                observer: '_enumClassType'
            }
        },

        behaviors: [
            VrBehavior.Move,
            VrBehavior.Resize,
            VrBehavior.Delete,
            VrBehavior.ConnectExtended,
            VrBehavior.Look,
            VrBehavior.ClassControl
        ],

        observers: [
            '_updateClass(xPos, yPos, width, height, depth, text1, text2, text3, classType)'
        ],

        _enumClassType: function (newValue) {
            var validTypes = ['class', 'abstract', 'interface'];
            if (validTypes.indexOf(newValue) === -1) {
                // set default value
                this.classType = 'class';
            }
        },

        _updateClass: function (xPos, yPos, width, height, depth, text1, text2, text3, classType) {
            if (this.getThreeJS()) {
                // compute width for fitting the text
                var newWidth = this._computeWidth();
                if (newWidth > 0) {
                    this.width = newWidth < this.maxWidth ? newWidth : this.maxWidth;
                }

                if (this.boxItems) {
                    var properties = this._getBoxItemProperties(this.width, height, depth, text1, text2, text3, classType);
                    this.splice('boxItems', 0, 3, properties[0], properties[1], properties[2]);
                }
                this.fire('vr-resize', {});
            }
        },

        _computeWidth: function () {
            // TODO: texture erstellung auslagern
            var dynamicTexture = new THREEx.DynamicTexture(this.width * 10, this.height * 10);
            dynamicTexture.texture.minFilter = THREE.NearestFilter;
            var maxWidth = 0;

            calcMax(this.text1);
            calcMax(this.text2);
            calcMax(this.text3);

            function calcMax(text) {
                var texts = text.split(THREEx.linebreak);
                texts.forEach(function (text) {
                    var newWidth = dynamicTexture.computeWidth(text, "64px Verdana");
                    if (newWidth > maxWidth) {
                        maxWidth = newWidth;
                    }
                });
            }

            return maxWidth / 10;
        },

        ready: function () {
            this.boxItems = this._getBoxItemProperties(this.width, this.height, this.depth, this.text1, this.text2, this.text3, this.classType);
        },

        _getBoxItemProperties: function (width, height, depth, text1, text2, text3, classType) {
            /* Hopefully not so Magic Calculation */

            // calculate box heights
            // TODO: texture erstellung auslagern
            var dynamicTexture = new THREEx.DynamicTexture(this.width * 10, this.height * 10);
            dynamicTexture.texture.minFilter = THREE.NearestFilter;
            var heightBox1 = 25; // fix default height for first box
            var heightBox2 = Math.ceil(dynamicTexture.computeHeight(text2, "64px Verdana") / 10);
            var heightBox3 = Math.ceil(dynamicTexture.computeHeight(text3, "64px Verdana") / 10);

            // calculate total height
            var sumHeight = heightBox1 + heightBox2 + heightBox3;
            if (sumHeight < height) {
                heightBox3 += height - sumHeight;
            } else {
                this.height = sumHeight;
            }

            // calculate y pos
            var padding = 0.5;
            var yValueBox1 = 0;
            var yValueBox2 = -(heightBox1 + padding);
            var yValueBox3 = yValueBox2 - (heightBox2 + padding);

            if (classType === 'abstract') {
                text1 = '<<abstract>>; ' + text1
            } else if (classType === 'interface') {
                text1 = '<<interface>>; ' + text1
            }

            function createBox(y, height, text, center) {
                return {
                    x: 0,
                    y: y,
                    width: width,
                    height: height,
                    depth: depth,
                    text: text,
                    textCenter: center
                };
            }

            return [
                createBox(yValueBox1, heightBox1, text1, true),
                createBox(yValueBox2, heightBox2, text2, false),
                createBox(yValueBox3, heightBox3, text3, false)
            ];
        }
    });
</script>
