<link rel="import" href="vr-three.html">
<script src="../js/vr-size-datastruct.js"></script>

<script>
    window.VrBehavior = window.VrBehavior || {};
    VrBehavior.InnerSizing = [VrBehavior.ThreeJS, {
        observers: ['_sizingHandler(width, height)'],

        ready: function() {
            this.sizeInformations = {
                "0": VrSizeDatastruct({height: 25}, {height: 25}, {height: 0.2, width:1}),
                "1": VrSizeDatastruct(null, null, {height: 0.4, width:1}),
                "2": VrSizeDatastruct(null, null, {height: 0.4, width:1})
            };

            // first setup
            this.boxItems = this._sizeInnerElements(this.width, this.height);
        },

        _sizingHandler: function(width, height) {
            if(this.boxItems) {
                var properties = this._sizeInnerElements(width, height);
                this.splice('boxItems', 0, 3, properties[0], properties[1], properties[2]);
            }
        },

        _sizeInnerElements: function(width, height) {
            var texts = [this.text1, this.text2, this.text3];

            // calculate sizes
            var size = (calculateSize.bind(this))([], width, height, 1, Object.keys(this.sizeInformations));

            // create properties
            var properties = size.map(handleY(0, function(size, i, y){
                return createProperties({x: 0, y: y}, size, texts[i]);
            }));

            return properties;

            // gets executed until hole space(width/heigth) is used
            // it needs more than one iteration if an element reaches its
            // min or max size
            function calculateSize(arr, width, height, percentage, posibilities) {
                var tmpHeight = tmpPercentage = 0;
                var tmpPosibilities = [];

                for(var key in this.sizeInformations) {
                    if(posibilities.indexOf(String(key)) == -1) { continue; }
                    var tmp = this.sizeInformations[key](width, proportion(1), height, proportion(percentage));
                    tmpHeight += tmp.diffHeight;
                    tmpPercentage += tmp.percentageHeight;
                    arr = append(arr, key, tmp.size);
                    if(tmp.percentageHeight != 0) { tmpPosibilities.push(key); }
                }

                // can cause endrecursion if maxWidth and minWidth
                //aren't set properly
                return (tmpHeight == 0) ? arr :
                    (calculateSize.bind(this))(arr, width, height + tmpHeight, tmpPercentage, tmpPosibilities);
            }

            function handleY(y, func) {
                return function(size, i) {
                    var property = func(size, i, y);
                    y -= size.height;
                    return property;
                }
            }

            function append(arr, index, value) {
                index = parseInt(index, 10);
                if(arr[index] === undefined) { arr.push(value) } else { arr[index] = value; }
                return arr;
            }

            // important if on element has reached it min/max height
            // calculates how much the percentage of all elements should be
            // increased
            function proportion(percentage) {
                return 1 / percentage;
            }

            function createProperties(position, size, text) {
                return {
                    x: position.x,
                    y: position.y,
                    width: size.width,
                    height: size.height,
                    depth: size.depth || 10,
                    text: text,
                    textCenter: true
                }
            }
        }
    }];
</script>
