<link rel="import" href="vr-three.html">
<script src="../js/vr-size-datastruct.js"></script>

<script>
    window.VrBehavior = window.VrBehavior || {};
    VrBehavior.InnerSizing = [VrBehavior.ThreeJS, {
        observers: ['_sizingHandler(width, height)'],

        ready: function() {
            this.innerSizingElements = [];
        },

        attached: function () {
            this._sizeInnerElements(this.width, this.height);
        },

        registerInnerSizingElement: function (element, min, max, percentage) {
            this.innerSizingElements.push({
              element: element,
              size: VrSizeDatastruct(min, max, percentage)
            });
        },

        _sizingHandler: function(width, height) {
            if(this.getThreeJS()) {
                this._sizeInnerElements(width, height);
            }
        },

        _sizeInnerElements: function(width, height) {
            var texts = [{text: this.text1, center: true},
                {text: this.text2, center: false},
                {text: this.text3, center: false}];

            var self = this;
            var size = calculateSize([], width, height, 1, Object.keys(this.innerSizingElements));

            return size.map(handleY(0, function(size, i, y) {
                setProperties(self.innerSizingElements[i]['element'], y, size);
                return createProperties({x: 0, y: y}, size, texts[i]);
            }));

            // gets executed until hole space(width/heigth) is used
            // it needs more than one iteration if an element reaches its
            // min or max size
            function calculateSize(arr, width, height, percentage, possibilities) {
                var tmpHeight = 0, tmpPercentage = 0;
                var tmpPossibilities = [];

                self.innerSizingElements.forEach(function (value, key) {
                    if(possibilities.indexOf(String(key)) >= 0) {
                      var tmp = value['size'](width, proportion(1), height, proportion(percentage));
                      tmpHeight += tmp.diffHeight;
                      tmpPercentage += tmp.percentageHeight;
                      arr = append(arr, key, tmp.size);
                      if(tmp.percentageHeight != 0) { tmpPossibilities.push(key); }
                    }
                });

                // can cause endrecursion if maxWidth and minWidth
                //aren't set properly
                if (tmpHeight == 0) {
                  return arr;
                } else {
                  return calculateSize(arr, width, height + tmpHeight, tmpPercentage, tmpPossibilities);
                }
            }

            function handleY(y, func) {
                return function(size, i) {
                    var property = func(size, i, y);
                    y -= size.height;
                    return property;
                }
            }

            function append(arr, index, value) {
                index = parseInt(index, 10);
                if(arr[index] === undefined) { arr.push(value) } else { arr[index] = value; }
                return arr;
            }

            // important if on element has reached it min/max height
            // calculates how much the percentage of all elements should be
            // increased
            function proportion(percentage) {
                return 1 / percentage;
            }

            function createProperties(position, size, text) {
                return {
                    x: position.x,
                    y: position.y,
                    width: size.width,
                    height: size.height,
                    depth: size.depth || 10,
                    text: text.text,
                    textCenter: text.center
                }
            }

            function setProperties(element, y, size) {
                element.yPos = y;
                element.width = size.width;
                element.height = size.height;
            }
        }
    }];
</script>
